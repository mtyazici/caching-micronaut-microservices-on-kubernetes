
:github-address: https://github.com/hazelcast-guides/caching-micronaut-microservices-on-kubernetes
:templates-url: templates:ROOT:page$/
:hazelcast: Hazelcast IMDG
:framework: Micronaut


= Getting Started with Hazelcast using Micronaut on Kubernetes

This guide helps you start with Hazelcast in Micronaut based microservice and deploy on Kubernetes.

include::{templates-url}/link-to-repo.adoc[]

== What Youâ€™ll Learn

In this guide, you will deploy Micronaut application on a Kubernetes cluster. Hazelcast cluster members will automatically discover each other using https://github.com/hazelcast/hazelcast-kubernetes[Hazelcast Kubernetes discovery plugin].

== Prerequisites

-   ~15 minutes

-   Docker (Docker for Desktop is good enough)

-   Kubernetes cluster (Docker for Desktop or Minikube is good enough)

-  JDK 1.8+

-  Apache Maven 3.2+


== About Deploying the Application to Kubernetes

We will take the application that we built on xref:hazelcast-embedded-micronaut:ROOT:index.adoc[Hazelcast Embedded Micronaut] and deploy it on Kubernetes.

In `pom.xml` we add the following dependecy for cluster members to find each other in the cluster.
[source, xml]
----
<dependency>
    <groupId>com.hazelcast</groupId>
    <artifactId>hazelcast-kubernetes</artifactId>
    <version>${hazelcast-kubernetes.version}</version>
</dependency>
----
And in the code we change `JoinConfig` in `HazelcastAdditionalSettings.java` to make Hazelcast instances able to discover each other in Kubernetes environment:

[source,java]
----
@Singleton
public class HazelcastAdditionalSettings
        implements BeanCreatedEventListener<HazelcastMemberConfiguration> {

    public HazelcastMemberConfiguration onCreated(BeanCreatedEvent<HazelcastMemberConfiguration> event) {
        HazelcastMemberConfiguration configuration = event.getBean();
        configuration.getGroupConfig().setName("micronaut-cluster");
        JoinConfig joinConfig = configuration.getNetworkConfig().getJoin();
        joinConfig.getMulticastConfig().setEnabled(false);
        joinConfig.getKubernetesConfig().setEnabled(true);
        return configuration;
    }
}
----

We also add the `kubernetes.yaml` file which will create two Micronaut applications and a service to connect them to outer world.


== Create a Docker Image


To create the container (Docker) image of the application, we will use Jib tool. It allows to build containers from Java applications without a Docker file or even changing the `pom.xml` file. To build the image, you can run the command below:
[source]
----
$ mvn clean compile com.google.cloud.tools:jib-maven-plugin:1.8.0:dockerBuild
----
This command will create a docker image named `caching-micronaut-microservices-on-kubernetes:0.1.0`. If you want an image with your choice of name to push it to some registry, you can run the following instead:

----
$ mvn clean compile com.google.cloud.tools:jib-maven-plugin:1.8.0:dockerBuild  -Dimage=YOUR-NAME/caching-micronaut-microservices-on-kubernetes:0.1.0
----

If you run the above command make sure to change the following part in the `kubernetes.yaml` file.
[source]
----
...
      containers:
        - name: hazelcast-micronaut-container
          image: caching-micronaut-microservices-on-kubernetes:0.1.0
          imagePullPolicy: IfNotPresent
          ports:
....
----

[TIP]
====
If you are using `Minikube` you can run the following command before the `mvn clean compile ...` and the docker image will be available to the docker daemon inside the Minikube. Note that this only applies to the shell you run this command.
[source,bash]
----
$ eval $(minikube docker-env)
----
====


== Configure RBAC

https://github.com/hazelcast/hazelcast-kubernetes[Hazelcast Kubernetes discovery plugin] makes calls to Kubernetes API to provide automatic member discovery. Therefore, it needs to have specific ClusterRole rules granted. You can apply the minimal RBAC configuration (for the `default` service account in the `default` namespace) with the following command.

By this time make sure you have your kubernetes environment running.
[source,bash]
----
kubectl apply -f rbac.yaml
----

[NOTE]
====
- If you use service account other than `default` or namespace other than `default`, you need to modify `rbac.yaml` file.
- If your Kubernetes cluster does not use RBAC, you can skip the "Configure RBAC" step
====

== Deploy Micronaut Application to Kubernetes

[source,shell script]
----
kubectl apply -f kubernetes.yaml
----

== Testing the Application
Launch a curl container inside kubernetes cluster. This will create an interactable shell.

[source,shell script]
----
$ kubectl run curl --rm --image=radial/busyboxplus:curl -i --tty
----

Put a value to Hazelcast cluster:

[source,shell script]
----
$ curl  "http://hazelcast-micronaut-service:8080/put?key=1&value=2"
{"value":"2","podName":"hazelcast-embedded-hazelcast-micronaut-container-0"}
----

Get the value from cluster in a loop and see that it is retrieved from different Pod Names.

[source,shell script]
----
$ while true; do curl "http://hazelcast-micronaut-service:8080/get?key=1"; sleep 2;echo; done
{"value":"2","podName":"hazelcast-micronaut-statefulset-1"}
{"value":"2","podName":"hazelcast-micronaut-statefulset-0"}
...
----

You can stop the command by `CTRL + C` and exit the shell by typing `exit`.

== Tearing Down the Application
To delete all Kubernetes resources you created, run the following commands.

[source,shell script]
----
$ kubectl delete -f kubernetes.yaml
$ kubectl delete -f rbac.yaml
----

== Summary

In this guide, we bootstrapped a Micronaut application and deployed it to Kubernetes. We pushed a key-value pair to one of the applications. Then we could get the key-value pair from both.

== See Also


- xref:hazelcast-embedded-kubernetes:ROOT:index.adoc[SpringBoot Application with Embedded Hazelcast on Kubernetes]
- xref:hazelcast-embedded-springboot:ROOT:index.adoc[Getting Started with Hazelcast using Spring Boot]





